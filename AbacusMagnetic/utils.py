import numpy as np
import unittest
import uuid
import json
import os
import sys

def init():
    '''initialize the workflow
        
    Unluckily, the argparse will be overwritten by the unittest, so we use
    sys.argv to pass the arguments to the unittest.
    '''
    if '--only-automatic-test-workflow=on' in sys.argv:
        sys.argv.remove('--only-automatic-test-workflow=on') # because we don't want to pass this to unittest
        return True
    return False

def sph_to_cart(r, theta, phi, deg=False):
    '''convert spherical coordinates to Cartesian coordinates'''
    if deg:
        theta = np.deg2rad(theta)
        phi = np.deg2rad(phi)
    x = r * np.sin(theta) * np.cos(phi)
    y = r * np.sin(theta) * np.sin(phi)
    z = r * np.cos(theta)
    return x, y, z

def cart_to_sph(x, y, z, deg=False):
    '''convert Cartesian coordinates to spherical coordinates'''
    r = np.sqrt(x**2 + y**2 + z**2)
    theta = np.arccos(z/r)
    phi = np.arctan2(y, x) % (2*np.pi)
    if deg:
        theta = np.rad2deg(theta)
        phi = np.rad2deg(phi)
    return r, theta, phi

def _listdict2dictlist(src):
    '''merge a list of dict in which all dicts have uniform keys, into a dict of list,
    in which keys are the same as the keys of the input dicts, values are lists of values
    of the input dicts'''
    if set([i for s in src for i in s.keys() ]) != set(src[0].keys()):
        raise ValueError('All dicts in the list should have the same keys')
    keys = src[0].keys()
    out = {k: [s[k] for s in src] for k in keys}
    return out

def _dict_as_text(d: dict):
    '''
    convert the dict to text
    '''
    code = str(uuid.uuid4()).replace('-', '')
    fn = f'{code}.json'
    with open(fn, 'w') as f:
        json.dump(d, f)
    with open(fn, 'r') as f:
        out = f.read()
    os.remove(fn)
    return out

def _text_as_dict(text: str):
    '''
    convert the text to dict
    '''
    code = str(uuid.uuid4()).replace('-', '')
    fn = f'{code}.json'
    with open(fn, 'w') as f:
        f.write(text)
    with open(fn, 'r') as f:
        out = json.load(f)
    os.remove(fn)
    return out

def convert_length_unit(length, unit_from, unit_to):
    '''convert length unit'''
    FACTOR = {'angstrom': 1, 'bohr': 1.889726125457828,
              'm': 1e-10, 'cm': 1e-8, 'a.u.': 1.889726125457828}

    return length / FACTOR[unit_from.lower()] * FACTOR[unit_to.lower()]

def convert_force_unit(force, unit_from, unit_to):
    '''convert force unit'''
    ENERGY = {'ev': 1, 'ry': 13.6056980659, 'ha': 27.21138602,
              'cm-1': 8065.54429, 'a.u.': 27.21138602}
    LENGTH = {'angstrom': 1, 'bohr': 1.889726125457828,
              'm': 1e-10, 'cm': 1e-8, 'a.u.': 1.889726125457828}
    
    unit_from = 'a.u./a.u.' if unit_from == 'a.u.' else unit_from
    unit_to = 'a.u./a.u.' if unit_to == 'a.u.' else unit_to
    
    u11, u12 = unit_from.lower().split('/')
    u21, u22 = unit_to.lower().split('/')
    
    return force * ENERGY[u11] / ENERGY[u21] / LENGTH[u12] * LENGTH[u22]

def convert_energy_unit(val, unit_from, unit_to):
    '''convert energy unit'''
    FACTOR = {'ev': 1, 'ry': 13.6056980659, 'ha': 27.21138602,
              'cm-1': 8065.54429, 'a.u.': 27.21138602,
              'j': 1.602176634e-19, 'kj/mol': 96.485, 'kcal/mol': 23.06035}
    return val / FACTOR[unit_from.lower()] * FACTOR[unit_to.lower()]              

def convert_pressure_unit(val, unit_from, unit_to):
    '''convert the pressure unit
    
    From https://unit-converter.org/UnitConverter/convert/?uc_class=1&uc_value=1&uc_unit=31&uc_cat=4&commit=Convert
    '''
    FACTOR = {'kbar': 1.0, 'bar': 1e3, 'kpa': 100000, 'gpa': 0.1, 'pa': 100000000,
              'atm': 986.92, 'mmhg': 750060}
    return val / FACTOR[unit_from.lower()] * FACTOR[unit_to.lower()]

def to_xyz(pos, elem, fn = 'pos.xyz'):
    '''
    quick export of the position to xyz file
    '''
    if not isinstance(elem, list):
        elem = [elem] * len(pos)
    
    with open(fn, 'w') as f:
        f.write(f'{len(pos)}\n')
        f.write(f'Generated by to_xyz\n')
        for p, e in zip(pos, elem):
            f.write(f'{e} {p[0]:.6f} {p[1]:.6f} {p[2]:.6f}\n')
    
    return fn

class TestDeltaSpinUtils(unittest.TestCase):
    
    def test_sph_and_cart(self):

        r, theta, phi = 2, np.random.rand()*np.pi, np.random.rand()*2*np.pi
        x, y, z = sph_to_cart(r, theta, phi)
        r_, theta_, phi_ = cart_to_sph(x, y, z)
        self.assertAlmostEqual(r, r_)
        self.assertAlmostEqual(theta, theta_)
        self.assertAlmostEqual(phi, phi_)
        
    def test_listdict2dictlist(self):
        '''test _listdict2dictlist'''
        src = [{'a': 1, 'b': 2}, {'a': 3, 'b': 4}]
        out = _listdict2dictlist(src)
        self.assertTrue('a' in out)
        self.assertTrue('b' in out)
        self.assertEqual(out['a'], [1, 3])
        self.assertEqual(out['b'], [2, 4])
        
        src = [{'a': 1, 'b': 2, 'c': 3}, {'a': 4, 'b': 5, 'c': 6}]
        out = _listdict2dictlist(src)
        self.assertTrue('a' in out)
        self.assertTrue('b' in out)
        self.assertTrue('c' in out)
        self.assertEqual(out['a'], [1, 4])
        self.assertEqual(out['b'], [2, 5])
        self.assertEqual(out['c'], [3, 6])
        
    def test_convert_force_unit(self):
        '''test convert_force_unit'''
        # the simplest
        force = 1.0
        unit_from = 'ev/angstrom'
        unit_to = 'ev/angstrom'
        self.assertAlmostEqual(convert_force_unit(force, unit_from, unit_to), 1.0)
        
        # ev/angstrom -> ry/angstrom
        unit_from = 'ev/angstrom'
        unit_to = 'ry/angstrom'
        self.assertAlmostEqual(convert_force_unit(force, unit_from, unit_to), 1.0/13.6056980659)
        
        # ev/angstrom -> ry/bohr
        unit_from = 'ev/angstrom'
        unit_to = 'ry/bohr'
        self.assertAlmostEqual(convert_force_unit(force, unit_from, unit_to), (1.0/13.6056980659) * 1.889726125457828)

        # test the case that is really needed: ev/angstrom -> a.u.
        unit_from = 'ev/angstrom'
        unit_to = 'a.u.'
        self.assertAlmostEqual(convert_force_unit(force, unit_from, unit_to), (1.0/27.21138602) * 1.889726125457828)

if __name__ == '__main__':
    test = init()
    unittest.main(exit=test)
